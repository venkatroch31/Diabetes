<html>
	<head>
		<style>
			div {
  			padding-top: 10px;
  			padding-right:200px;
  			padding-bottom: 50px;
  			padding-left: 200px;  
			align:left;
			
			}
			
		</style>
	</head>
	
	<body>
		<center><img src="credit-card.jpg" /></center>
		<div>
			<h1><center>Pima Indian Diabetes</center></h1>
			<h2>Introduction</h2>
			<p>
				The Pima are a group of Native Americans living in Arizona. A genetic predisposition allowed this group to survive normally to a diet poor of carbohydrates for years. In the recent years, because of a sudden shift from traditional agricultural crops to processed foods, together with a decline in physical activity, made them develop the highest prevalence of type 2 diabetes and for this reason they have been subject of many studies.
			</p>
			
			<p>
				Diabetes is a disease which occurs when the blood glucose level becomes high, which 
       				ultimately leads to other health problems such as heart diseases, kidney disease etc. 
       					Diabetes is caused mainly due to the consumption of highly processed food, bad 
       					consumption habits etc. According to WHO, the number of people with diabetes has 
       						been increased over the years. 

			</p>
			<h2>Dataset</h2>
			<p>
				Download the dataset from<a href="https://www.kaggle.com/uciml/pima-indians-diabetes-database/downloads/pima-indians-diabetes-database.zip/1">kaggle</a> 
			</p>
			<p>
				The dataset includes data from 768 women with 8 characteristics, in particular:
				<ul>
					<li>Pregnancies: Number of times pregnant</li>
					<li>Glucose: Plasma glucose concentration a 2 hours in an oral glucose tolerance test</li>
					<li>BloodPressure: Diastolic blood pressure (mm Hg)</li>
					<li>SkinThickness: Triceps skin fold thickness (mm)</li>
					<li>Insulin: 2-Hour serum insulin (mu U/ml)</li>
					<li>BMI: Body mass index (weight in kg/(height in m)^2)</li>
					<li>DiabetesPedigreeFunction: Diabetes pedigree function</li>
					<li>Age: Age (years)</li>
					<li>Outcome: Class variable (0 or 1)</li>
					
				</ul>
				The last column 'Outcome' of the dataset indicates if the person has been diagnosed with diabetes (1) or not (0)
			</p>
			<h2>Problem</h2>
			<p>
				The type of dataset and problem is a classic supervised binary classification. Given a number of elements all with certain characteristics (features), we want to build a machine learning model to identify people affected by type 2 diabetes.
			</p>
			<p>
				To solve the problem we will have to analyse the data, do any required transformation and normalisation, apply a machine learning algorithm, train a model, check the performance of the trained model and iterate with other algorithms until we find the most performant for our type of dataset.
			</p>
			<h2>Setup</h2>
			
			<p>
				Import neceessary libraries. Letâ€™s begin:
			</p>
		
			<div align="left" style="background-color:lightblue; padding-left:10px" style="overflow-y:hidden;overflow-x:scroll">
				<code>
					
					import pandas as pd</br>
					import matplotlib.pyplot as plt</br>
					import re</br>
					import numpy as np</br>
					import seaborn as sns</br>
					import time</br>
					import warnings</br>
					import sqlite3</br>
					warnings.filterwarnings("ignore")</br>
					from nltk.corpus import stopwords</br>
					from sklearn.preprocessing import normalize</br>
					from sklearn.feature_extraction.text import CountVectorizer</br>
					from sklearn.manifold import TSNE</br>
					from sklearn.neighbors import KNeighborsClassifier</br>
					from sklearn.metrics import confusion_matrix</br>
					from sklearn.metrics.classification import accuracy_score, log_loss</br>
					from sklearn.svm import SVC</br>
					from sklearn.calibration import CalibratedClassifierCV</br>
					from sklearn.model_selection import train_test_split</br>
					from sklearn.model_selection import GridSearchCV</br>
					from sklearn.metrics import normalized_mutual_info_score</br>
					from sklearn.ensemble import RandomForestClassifier</br>
					from sklearn import metrics</br>
					from nltk.stem.porter import PorterStemmer</br>

				</code>
			</div>
			<h2>Load the dataset</h2>
			<div align="left" style="background-color:lightblue; padding-left:10px" style="overflow-y:hidden;overflow-x:scroll">
				<code>
					
					diabetes = pd.read_csv('diabetes.csv')</br>
					print('\nFeatures : ', diabetes.columns.values)</br>
					Features :  ['Pregnancies' 'Glucose' 'BloodPressure' 'SkinThickness' 'Insulin' 'BMI'
 						'DiabetesPedigreeFunction' 'Age' 'Outcome']</br>
					

				</code>
			</div>
			<h2>Data correlation matrix</h2>
			<p>
				The correlation matrix is an important tool to understand the correlation between the different characteristics. The values range from -1 to 1 and the closer a value is to 1 the bettere correlation there is between two characteristics. Let's calculate the correlation matrix for our dataset.
			</p>
			<div align="left" style="background-color:lightblue; padding-left:10px" style="overflow-y:hidden;overflow-x:scroll">
				<code>
					
					plt.figure(figsize=(12,10))</br>
					p=sns.heatmap(diabetes.corr(), annot=True,cmap ='RdYlGn')  </br>
					

				</code>
			</div>
			<h2>Visualise the Data</h2>
			<p>
				Visualising the data is an important step of the data analysis. With a graphical visualisation of the data we have a better understanding of the various features values distribution: for example we can understand what's the average age of the people or the average BMI etc...
			</p>
			<center><img src=""/></center>
			<div align="left" style="background-color:lightblue; padding-left:10px" style="overflow-y:hidden;overflow-x:scroll">
				<code>
					
					df = diabetes.hist(figsize=(12,10))</br>					

				</code>
			</div>
			
			
				<p>
					Following columns or variables have an invalid zero value:
					<ul>
						<li>Glucose</li>
						<li>BloodPressure</li>
						<li>SkinThickness</li>
						<li>Insulin</li>
						<li>BMI</li>
					</ul>
					
				</p>
				<p>
					
					It is better to replace zeros with nan since after that counting them would be easier and zeros need to be replaced with suitable values
					
				</p>
				<div align="left" style="background-color:lightblue; padding-left:10px" style="overflow-y:hidden;overflow-x:scroll">
					<code>
					
						diabetes_copy = diabetes.copy(deep = True)</br>
						diabetes_copy[['Glucose','BloodPressure','SkinThickness','Insulin','BMI']] = diabetes_copy[['Glucose','BloodPressure','SkinThickness','Insulin','BMI']].replace(0,np.NaN)
						</br>
					
						print(diabetes_copy.isnull().sum())</br>					

					</code>
				</div>
				
				<div align="left" style="overflow-y:hidden;overflow-x:scroll">
					<code>
					
						Pregnancies                   0</br>
						Glucose                       5</br>					
						BloodPressure                35</br>
						SkinThickness               227</br>
						Insulin                     374</br>
						BMI                          11</br>
						DiabetesPedigreeFunction      0</br>
						Age                           0</br>
						Outcome                       0</br>
						dtype: int64

					</code>
				</div>

			<h2>Data cleaning and transformation</h2>
			<p>
				We have noticed from the previous analysis that some patients have missing data for some of the features. Machine learning algorithms don't work very well when the data is missing so we have to find a solution to "clean" the data we have.
			</p>
			<p>
				The easiest option could be to eliminate all those patients with null/zero values, but in this way we would eliminate a lot of important data.
			</p>
			<p>
				Another option is to calculate the mean and the median value for a specific column and substitute that value everywhere (in the same column) we have zero or null. Let's see how to apply this second method.</p>
			</p>
			<div align="left" style="background-color:lightblue; padding-left:10px"; style="overflow-y:hidden;overflow-x:scroll">
				<code>
					
					diabetes_copy['Glucose'].fillna(diabetes_copy['Glucose'].mean(), inplace = True)</br>
					diabetes_copy['BloodPressure'].fillna(diabetes_copy['BloodPressure'].mean(), inplace = True)</br>
					diabetes_copy['SkinThickness'].fillna(diabetes_copy['SkinThickness'].median(), inplace = True)</br>
					diabetes_copy['Insulin'].fillna(diabetes_copy['Insulin'].median(), inplace = True)</br>
					diabetes_copy['BMI'].fillna(diabetes_copy['BMI'].median(), inplace = True)</br>

				</code>
			</div>
			
			
			
		</div>
	</body>
</html>
